/*
Author: vpetrigo
Task:
В небоскребе n этажей. Известно, что если уронить стеклянный шарик с этажа номер
p, и шарик разобъется, то если уронить шарик с этажа номер p+1, то он тоже разобъется.
Также известно, что при броске с последнего этажа шарик всегда разбивается.
Вы хотите определить минимальный номер этажа, при падении с которого шарик разбивается.
Для проведения экспериментов у вас есть два шарика. Вы можете разбить их все,
но в результате вы должны абсолютно точно определить этот номер.
Определите, какого числа бросков достаточно, чтобы заведомо решить эту задачу.

Формат входных данных
Программа получает на вход количество этажей в небоскребе.

Формат выходных данных
Требуется вывести наименьшее число бросков, при котором можно всегда решить задачу.
Примечание
Комментарий к первому примеру. Нужно бросить шарик со 2-го этажа.
Если он разобъется, то бросим второй шарик с 1-го этажа, а если не разобъется - то бросим шарик с 3-го этажа.

Подсказки
1. Как следует действовать, если шарик был бы только один?
2. Пусть шариков два и мы бросили один шарик с этажа номер k.
Как мы будем действовать в зависимости от того, разобъется ли шарик или нет?
3. Пусть f(n) - это минимальное число бросков, за которое можно определить искомый этаж,
если бы в небоскребе было n этажей. Выразите f(n) через значения f(a) для меньших значений a.
Sample Input 1:
4
Sample Output 1:
2

Sample Input 2:
5
Sample Output 2:
3

*/

#include <iostream>
#include <algorithm>

using namespace std;

int ball_fall(int eggs, int floors) {
    // if we have only one egg
    // then we have to check all the floors below
    if (eggs == 1)
        return floors;

    // in case only 2 or less floors left
    // we also have to check all
    if (floors <= 2)
        return floors;

    int min_drops = -1;
    for (int floor = 1; floor < floors; ++floor) {
        int max_drop_below = ball_fall(eggs - 1, floor - 1);
        int max_drop_above = ball_fall(eggs, floors - floor);
        int max_k = max(max_drop_below, max_drop_above);

        if (min_drops == -1 || min_drops > max_k) {
            min_drops = max_k;
        }
    }

    return min_drops + 1;
}

int main() {
    const int balls = 2;
    int n;

    cin >> n;
    cout << ball_fall(balls, n - 1) << endl;

    return 0;
}
